use ic_base_types::{CanisterId, NumBytes, NumSeconds, PrincipalId, SubnetId};
use ic_btc_types::NetworkSnakeCase;
use ic_btc_types_internal::{
    BitcoinAdapterRequestWrapper, BitcoinAdapterResponse, BitcoinAdapterResponseWrapper,
    CanisterGetSuccessorsRequestInitial, CanisterGetSuccessorsResponseComplete,
    GetSuccessorsRequest, GetSuccessorsResponse,
};
use ic_ic00_types::{BitcoinGetSuccessorsResponse, Payload as _};
use ic_interfaces::messages::CanisterMessage;
use ic_registry_subnet_features::SubnetFeatures;
use ic_registry_subnet_type::SubnetType;
use ic_replicated_state::replicated_state::testing::ReplicatedStateTesting;
use ic_replicated_state::testing::{CanisterQueuesTesting, SystemStateTesting};
use ic_replicated_state::{
    metadata_state::subnet_call_context_manager::BitcoinGetSuccessorsContext,
    replicated_state::PeekableOutputIterator, replicated_state::ReplicatedStateMessageRouting,
    BitcoinStateError, CanisterState, ReplicatedState, SchedulerState, StateError, SystemState,
};
use ic_test_utilities::mock_time;
use ic_test_utilities::state::arb_replicated_state_with_queues;
use ic_test_utilities::types::{
    ids::user_test_id,
    messages::{RequestBuilder, ResponseBuilder},
};
use ic_types::{
    messages::{Payload, Request, RequestOrResponse, Response, MAX_RESPONSE_COUNT_BYTES},
    CountBytes, Cycles, Time,
};
use proptest::prelude::*;
use std::collections::VecDeque;
use std::str::FromStr;
use std::sync::Arc;

const SUBNET_ID: SubnetId = SubnetId::new(PrincipalId::new(29, [0xfc; 29]));
const CANISTER_ID: CanisterId = CanisterId::from_u64(42);
const OTHER_CANISTER_ID: CanisterId = CanisterId::from_u64(13);
const MAX_CANISTER_MEMORY_SIZE: NumBytes = NumBytes::new(u64::MAX / 2);
const SUBNET_AVAILABLE_MEMORY: i64 = i64::MAX / 2;

fn request_from(canister_id: CanisterId) -> RequestOrResponse {
    RequestBuilder::default()
        .sender(canister_id)
        .receiver(CANISTER_ID)
        .build()
        .into()
}

fn request_to(canister_id: CanisterId) -> Request {
    RequestBuilder::default()
        .sender(CANISTER_ID)
        .receiver(canister_id)
        .build()
}

fn response_from(canister_id: CanisterId) -> Response {
    ResponseBuilder::default()
        .respondent(canister_id)
        .originator(CANISTER_ID)
        .build()
}

fn response_to(canister_id: CanisterId) -> Response {
    ResponseBuilder::default()
        .respondent(CANISTER_ID)
        .originator(canister_id)
        .build()
}

/// Fixture using `SUBNET_ID` as its own subnet id and `CANISTER_ID` as the id
/// for the model canister used to send requests (responses) to and from.
/// Such messages are generated by the functions `request_from` et. al.
struct ReplicatedStateFixture {
    state: ReplicatedState,
}

impl ReplicatedStateFixture {
    fn new() -> ReplicatedStateFixture {
        ReplicatedStateFixture::from_canister_ids(&[CANISTER_ID])
    }

    fn from_canister_ids(canister_ids: &[CanisterId]) -> ReplicatedStateFixture {
        let mut state = ReplicatedState::new(SUBNET_ID, SubnetType::Application);
        for canister_id in canister_ids {
            let scheduler_state = SchedulerState::default();
            let system_state = SystemState::new_running(
                *canister_id,
                user_test_id(24).get(),
                Cycles::new(1 << 36),
                NumSeconds::from(100_000),
            );
            state.put_canister_state(CanisterState::new(system_state, None, scheduler_state));
        }
        ReplicatedStateFixture { state }
    }

    fn push_input(
        &mut self,
        msg: RequestOrResponse,
    ) -> Result<(), (StateError, RequestOrResponse)> {
        self.state.push_input(
            msg,
            MAX_CANISTER_MEMORY_SIZE,
            &mut SUBNET_AVAILABLE_MEMORY.clone(),
        )
    }

    fn pop_input(&mut self) -> Option<CanisterMessage> {
        self.state
            .canister_state_mut(&CANISTER_ID)
            .unwrap()
            .pop_input()
    }

    fn push_output_request(
        &mut self,
        request: Request,
        time: Time,
    ) -> Result<(), (StateError, Arc<Request>)> {
        self.state
            .canister_state_mut(&CANISTER_ID)
            .unwrap()
            .push_output_request(request.into(), time)
    }

    fn push_output_response(&mut self, response: Response) {
        self.state
            .canister_state_mut(&CANISTER_ID)
            .unwrap()
            .push_output_response(response.into());
    }

    fn push_to_streams(&mut self, msgs: Vec<RequestOrResponse>) {
        let mut streams = self.state.take_streams();
        for msg in msgs.into_iter() {
            streams.push(SUBNET_ID, msg);
        }
        self.state.put_streams(streams);
    }

    fn total_memory_taken(&self) -> NumBytes {
        self.state.total_and_message_memory_taken().0
    }

    fn message_memory_taken(&self) -> NumBytes {
        self.state.total_and_message_memory_taken().1
    }

    fn remote_subnet_input_schedule(&self) -> &VecDeque<CanisterId> {
        self.state
            .canister_state(&CANISTER_ID)
            .unwrap()
            .system_state
            .queues()
            .get_remote_subnet_input_schedule()
    }

    fn local_subnet_input_schedule(&self) -> &VecDeque<CanisterId> {
        self.state
            .canister_state(&CANISTER_ID)
            .unwrap()
            .system_state
            .queues()
            .get_local_subnet_input_schedule()
    }
}

fn assert_total_memory_taken(total_memory_usage: usize, fixture: &ReplicatedStateFixture) {
    assert_eq!(
        total_memory_usage as u64,
        fixture.total_memory_taken().get()
    );
}

fn assert_total_memory_taken_with_messages(
    total_memory_usage: usize,
    fixture: &ReplicatedStateFixture,
) {
    let (raw_total_memory, message_memory_taken) =
        fixture.state.raw_total_and_message_memory_taken();
    assert_eq!(
        total_memory_usage as u64,
        raw_total_memory.get() + message_memory_taken.get()
    );
}

fn assert_message_memory_taken(queues_memory_usage: usize, fixture: &ReplicatedStateFixture) {
    assert_eq!(
        queues_memory_usage as u64,
        fixture.message_memory_taken().get()
    );
}

fn assert_subnet_available_memory(
    initial_available_memory: i64,
    queues_memory_usage: usize,
    actual: i64,
) {
    assert_eq!(
        initial_available_memory - queues_memory_usage as i64,
        actual
    );
}

#[test]
fn memory_taken_by_canister_queues() {
    let mut fixture = ReplicatedStateFixture::new();
    let mut subnet_available_memory = SUBNET_AVAILABLE_MEMORY;

    // Zero memory used initially.
    assert_eq!(0, fixture.total_memory_taken().get());

    // Push a request into a canister input queue.
    fixture
        .state
        .push_input(
            request_from(OTHER_CANISTER_ID),
            MAX_CANISTER_MEMORY_SIZE,
            &mut subnet_available_memory,
        )
        .unwrap();

    // Reserved memory for one response.
    assert_total_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_total_memory_taken_with_messages(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_message_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_subnet_available_memory(
        SUBNET_AVAILABLE_MEMORY,
        MAX_RESPONSE_COUNT_BYTES,
        subnet_available_memory,
    );

    // Pop input request.
    assert!(fixture.pop_input().is_some());

    // Unchanged memory usage.
    assert_total_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_total_memory_taken_with_messages(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_message_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);

    // Push a response into the output queue.
    let response = response_to(OTHER_CANISTER_ID);
    fixture.push_output_response(response.clone());

    // Memory used by response only.
    assert_total_memory_taken(response.count_bytes(), &fixture);
    assert_total_memory_taken_with_messages(response.count_bytes(), &fixture);
    assert_message_memory_taken(response.count_bytes(), &fixture);
}

#[test]
fn memory_taken_by_subnet_queues() {
    let mut fixture = ReplicatedStateFixture::new();
    let mut subnet_available_memory = SUBNET_AVAILABLE_MEMORY;

    // Zero memory used initially.
    assert_eq!(0, fixture.total_memory_taken().get());

    // Push a request into the subnet input queues. Should ignore the
    // `max_canister_memory_size` argument.
    fixture
        .state
        .push_input(
            request_to(SUBNET_ID.into()).into(),
            0.into(),
            &mut subnet_available_memory,
        )
        .unwrap();

    // Reserved memory for one response.
    assert_total_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_total_memory_taken_with_messages(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_message_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_subnet_available_memory(
        SUBNET_AVAILABLE_MEMORY,
        MAX_RESPONSE_COUNT_BYTES,
        subnet_available_memory,
    );

    // Pop subnet input request.
    assert!(fixture.state.pop_subnet_input().is_some());

    // Unchanged memory usage.
    assert_total_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_total_memory_taken_with_messages(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_message_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);

    // Push a response into the subnet output queues.
    let response = response_from(SUBNET_ID.into());
    fixture
        .state
        .push_subnet_output_response(response.clone().into());

    // Memory used by response only.
    assert_total_memory_taken(response.count_bytes(), &fixture);
    assert_total_memory_taken_with_messages(response.count_bytes(), &fixture);
    assert_message_memory_taken(response.count_bytes(), &fixture);
}

#[test]
fn memory_taken_by_stream_responses() {
    let mut fixture = ReplicatedStateFixture::new();

    // Zero memory used initially.
    assert_eq!(0, fixture.total_memory_taken().get());

    // Push a request and a response into a stream.
    let response = response_to(OTHER_CANISTER_ID);
    fixture.push_to_streams(vec![
        request_to(OTHER_CANISTER_ID).into(),
        response.clone().into(),
    ]);

    // Memory only used by response, not request.
    assert_total_memory_taken(response.count_bytes(), &fixture);
    assert_total_memory_taken_with_messages(response.count_bytes(), &fixture);
    assert_message_memory_taken(response.count_bytes(), &fixture);
}

#[test]
fn system_subnet_memory_taken_by_canister_queues() {
    let mut fixture = ReplicatedStateFixture::new();
    let mut subnet_available_memory = SUBNET_AVAILABLE_MEMORY;

    // Make it a system subnet.
    fixture.state.metadata.own_subnet_type = SubnetType::System;

    // Zero memory used initially.
    assert_eq!(0, fixture.total_memory_taken().get());

    // Push a request into a canister input queue.
    fixture
        .state
        .push_input(
            request_from(OTHER_CANISTER_ID),
            MAX_CANISTER_MEMORY_SIZE,
            &mut subnet_available_memory,
        )
        .unwrap();

    // System subnets don't account for messages in `total_and_message_memory_taken()`.
    assert_total_memory_taken(0, &fixture);
    // But do in other `memory_taken()` methods.
    assert_total_memory_taken_with_messages(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_message_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    // And `&mut fixture.subnet_available_memory` is updated by the push.
    assert_subnet_available_memory(
        SUBNET_AVAILABLE_MEMORY,
        MAX_RESPONSE_COUNT_BYTES,
        subnet_available_memory,
    );
}

#[test]
fn system_subnet_memory_taken_by_subnet_queues() {
    // Make it a system subnet.
    let mut fixture = ReplicatedStateFixture::new();
    fixture.state.metadata.own_subnet_type = SubnetType::System;

    let mut subnet_available_memory = SUBNET_AVAILABLE_MEMORY;

    // Zero memory used initially.
    assert_eq!(0, fixture.total_memory_taken().get());

    // Push a request into the subnet input queues. Should ignore the
    // `max_canister_memory_size` argument.
    fixture
        .state
        .push_input(
            request_to(SUBNET_ID.into()).into(),
            0.into(),
            &mut subnet_available_memory,
        )
        .unwrap();

    // System subnets don't account for subnet queue messages in `total_and_message_memory_taken()`.
    assert_total_memory_taken(0, &fixture);
    // But do in other `memory_taken()` methods.
    assert_total_memory_taken_with_messages(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_message_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    // And `&mut subnet_available_memory` is updated by the push.
    assert_subnet_available_memory(
        SUBNET_AVAILABLE_MEMORY,
        MAX_RESPONSE_COUNT_BYTES,
        subnet_available_memory,
    );
}

#[test]
fn system_subnet_memory_taken_by_stream_responses() {
    let mut fixture = ReplicatedStateFixture::new();

    // Make it a system subnet.
    fixture.state.metadata.own_subnet_type = SubnetType::System;

    // Zero memory used initially.
    assert_eq!(0, fixture.total_memory_taken().get());

    // Push a request and a response into a stream.
    let response = response_to(OTHER_CANISTER_ID);
    fixture.push_to_streams(vec![
        request_to(OTHER_CANISTER_ID).into(),
        response.clone().into(),
    ]);

    // System subnets don't account for stream responses in `total_and_message_memory_taken()`.
    assert_total_memory_taken(0, &fixture);
    // But do in other `memory_taken()` methods.
    assert_total_memory_taken_with_messages(response.count_bytes(), &fixture);
    assert_message_memory_taken(response.count_bytes(), &fixture);
}

#[test]
fn push_subnet_queues_input_respects_subnet_available_memory() {
    let mut fixture = ReplicatedStateFixture::new();
    let initial_available_memory = MAX_RESPONSE_COUNT_BYTES as i64;
    let mut subnet_available_memory = initial_available_memory;

    // Zero memory used initially.
    assert_eq!(0, fixture.total_memory_taken().get());

    // Push a request into the subnet input queues. Should ignore the
    // `max_canister_memory_size` argument.
    fixture
        .state
        .push_input(
            request_to(SUBNET_ID.into()).into(),
            0.into(),
            &mut subnet_available_memory,
        )
        .unwrap();

    // Reserved memory for one response.
    assert_total_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_total_memory_taken_with_messages(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_message_memory_taken(MAX_RESPONSE_COUNT_BYTES, &fixture);
    assert_subnet_available_memory(
        initial_available_memory,
        MAX_RESPONSE_COUNT_BYTES,
        subnet_available_memory,
    );

    // Push a second request into the subnet input queues.
    let res = fixture.state.push_input(
        request_to(SUBNET_ID.into()).into(),
        0.into(),
        &mut subnet_available_memory,
    );

    // No more memory for a second request.
    assert_eq!(
        Err((
            StateError::OutOfMemory {
                requested: (MAX_RESPONSE_COUNT_BYTES as u64).into(),
                available: 0.into()
            },
            request_to(SUBNET_ID.into()).into(),
        )),
        res
    );

    // Unchanged memory usage.
    assert_eq!(
        MAX_RESPONSE_COUNT_BYTES as u64,
        fixture.total_memory_taken().get()
    );
    assert_eq!(0, subnet_available_memory);
}

#[test]
fn push_input_queues_respects_local_remote_subnet() {
    let mut fixture = ReplicatedStateFixture::new();

    // Assert the queues are empty.
    assert!(fixture.pop_input().is_none());
    assert!(fixture.state.canister_state(&OTHER_CANISTER_ID).is_none());

    // Push message from the remote canister, should be in the remote subnet
    // queue.
    fixture.push_input(request_from(OTHER_CANISTER_ID)).unwrap();
    assert_eq!(fixture.remote_subnet_input_schedule().len(), 1);

    // Push message from the local canister, should be in the local subnet queue.
    fixture.push_input(request_from(CANISTER_ID)).unwrap();
    assert_eq!(fixture.local_subnet_input_schedule().len(), 1);

    // Push message from the local subnet, should be in the local subnet queue.
    fixture
        .push_input(request_from(CanisterId::new(SUBNET_ID.get()).unwrap()))
        .unwrap();
    assert_eq!(fixture.local_subnet_input_schedule().len(), 2);
}

#[test]
fn push_request_bitcoin_respects_bitcoin_feature_flag() {
    let mut state = ReplicatedState::new(SUBNET_ID, SubnetType::Application);

    let request = BitcoinAdapterRequestWrapper::GetSuccessorsRequest(GetSuccessorsRequest {
        processed_block_hashes: vec![vec![10; 32]],
        anchor: vec![10; 32],
    });

    // Bitcoin feature is disabled, enqueueing a request should fail.
    assert_eq!(
        state.push_request_bitcoin(request.clone()),
        Err(StateError::BitcoinStateError(
            BitcoinStateError::FeatureNotEnabled
        ))
    );

    // Bitcoin feature is paused, enqueueing a request should fail.
    state.metadata.own_subnet_features =
        SubnetFeatures::from_str("bitcoin_testnet_paused").unwrap();
    assert_eq!(
        state.push_request_bitcoin(request.clone()),
        Err(StateError::BitcoinStateError(
            BitcoinStateError::FeatureNotEnabled
        ))
    );

    // Bitcoin feature is enabled, enqueueing a request should succeed.
    state.metadata.own_subnet_features = SubnetFeatures::from_str("bitcoin_testnet").unwrap();
    state.push_request_bitcoin(request).unwrap();
}

#[test]
fn push_response_bitcoin_respects_bitcoin_feature_flag() {
    let mut state = ReplicatedState::new(SUBNET_ID, SubnetType::Application);

    let response = BitcoinAdapterResponse {
        response: BitcoinAdapterResponseWrapper::GetSuccessorsResponse(
            GetSuccessorsResponse::default(),
        ),
        callback_id: 0,
    };

    // Bitcoin feature is disabled, enqueueing a response should fail.
    assert_eq!(
        state.push_response_bitcoin(response.clone()),
        Err(StateError::BitcoinStateError(
            BitcoinStateError::FeatureNotEnabled
        ))
    );

    // Enable bitcoin feature and push two requests.
    state.metadata.own_subnet_features = SubnetFeatures::from_str("bitcoin_testnet").unwrap();
    state
        .push_request_bitcoin(BitcoinAdapterRequestWrapper::GetSuccessorsRequest(
            GetSuccessorsRequest {
                processed_block_hashes: vec![vec![10; 32]],
                anchor: vec![10; 32],
            },
        ))
        .unwrap();
    state
        .push_request_bitcoin(BitcoinAdapterRequestWrapper::GetSuccessorsRequest(
            GetSuccessorsRequest {
                processed_block_hashes: vec![vec![20; 32]],
                anchor: vec![20; 32],
            },
        ))
        .unwrap();

    // Pushing a response when bitcoin feature is enabled should succeed.
    state.push_response_bitcoin(response).unwrap();

    // Pause bitcoin feature, responses should still be enqueued successfully.
    state.metadata.own_subnet_features =
        SubnetFeatures::from_str("bitcoin_testnet_paused").unwrap();
    state
        .push_response_bitcoin(BitcoinAdapterResponse {
            response: BitcoinAdapterResponseWrapper::GetSuccessorsResponse(
                GetSuccessorsResponse::default(),
            ),
            callback_id: 1,
        })
        .unwrap();
}

#[test]
fn state_equality_with_bitcoin() {
    let mut state = ReplicatedState::new(SUBNET_ID, SubnetType::Application);

    // Enable bitcoin feature.
    state.metadata.own_subnet_features = SubnetFeatures::from_str("bitcoin_testnet").unwrap();

    let original_state = state.clone();

    state
        .push_request_bitcoin(BitcoinAdapterRequestWrapper::GetSuccessorsRequest(
            GetSuccessorsRequest {
                processed_block_hashes: vec![vec![10; 32]],
                anchor: vec![10; 32],
            },
        ))
        .unwrap();

    // The bitcoin state is different and so the states cannot be equal.
    assert_ne!(original_state, state);
}

#[test]
fn insert_bitcoin_response_non_matching() {
    let mut state = ReplicatedState::new(SUBNET_ID, SubnetType::Application);

    assert_eq!(
        state.push_response_bitcoin(BitcoinAdapterResponse {
            response: BitcoinAdapterResponseWrapper::CanisterGetSuccessorsResponse(
                CanisterGetSuccessorsResponseComplete {
                    blocks: vec![],
                    next: vec![],
                },
            ),
            callback_id: 0,
        }),
        Err(StateError::BitcoinStateError(
            BitcoinStateError::NonMatchingResponse { callback_id: 0 }
        ))
    );
}

#[test]
fn insert_bitcoin_response() {
    let mut state = ReplicatedState::new(SUBNET_ID, SubnetType::Application);

    state
        .metadata
        .subnet_call_context_manager
        .push_bitcoin_get_successors_request(BitcoinGetSuccessorsContext {
            request: RequestBuilder::default().build(),
            payload: CanisterGetSuccessorsRequestInitial {
                network: NetworkSnakeCase::Regtest,
                anchor: vec![],
                processed_block_hashes: vec![],
            },
            time: mock_time(),
        });

    let response = CanisterGetSuccessorsResponseComplete {
        blocks: vec![],
        next: vec![],
    };

    state
        .push_response_bitcoin(BitcoinAdapterResponse {
            response: BitcoinAdapterResponseWrapper::CanisterGetSuccessorsResponse(
                response.clone(),
            ),
            callback_id: 0,
        })
        .unwrap();

    assert_eq!(
        state.consensus_queue[0].response_payload,
        Payload::Data(BitcoinGetSuccessorsResponse::Complete(response).encode())
    );
}

#[test]
fn time_out_requests_updates_subnet_input_schedules_correctly() {
    let mut fixture = ReplicatedStateFixture::from_canister_ids(&[CANISTER_ID, OTHER_CANISTER_ID]);

    // Push 3 requests into the canister with id `local_canister_id1`:
    // - one to self.
    // - one to a another local canister.
    // - one to a remote canister.
    let remote_canister_id = CanisterId::from_u64(123);
    for receiver in [CANISTER_ID, OTHER_CANISTER_ID, remote_canister_id] {
        fixture
            .push_output_request(request_to(receiver), mock_time())
            .unwrap();
    }

    // Time out everything, then check subnet input schedules are as expected.
    assert_eq!(
        3,
        fixture
            .state
            .time_out_requests(Time::from_nanos_since_unix_epoch(u64::MAX)),
    );
    assert_eq!(2, fixture.local_subnet_input_schedule().len());
    for canister_id in [CANISTER_ID, OTHER_CANISTER_ID] {
        assert!(fixture.local_subnet_input_schedule().contains(&canister_id));
    }
    assert_eq!(
        fixture.remote_subnet_input_schedule(),
        &VecDeque::from(vec![remote_canister_id])
    );
}

proptest! {
    #[test]
    fn peek_and_next_consistent(
        (mut replicated_state, _, total_requests) in arb_replicated_state_with_queues(SUBNET_ID, 20, 20, Some(8))
    ) {
        let mut output_iter = replicated_state.output_into_iter();

        let mut num_requests = 0;
        while let Some((queue_id, msg)) = output_iter.peek() {
            num_requests += 1;
            assert_eq!(Some((queue_id, msg.clone())), output_iter.next());
        }

        drop(output_iter);
        assert_eq!(total_requests, num_requests);
        assert_eq!(replicated_state.output_message_count(), 0);
    }

    /// Replicated state with multiple canisters, each with multiple output queues
    /// of size 1. Some messages are consumed, some (size 1) queues are excluded.
    ///
    /// Expect consumed + excluded to equal initial size. Expect the messages in
    /// excluded queues to be left in the state.
    #[test]
    fn peek_and_next_consistent_with_ignore(
        (mut replicated_state, _, total_requests) in arb_replicated_state_with_queues(SUBNET_ID, 20, 20, None),
        start in 0..=1,
        exclude_step in 2..=5,
    ) {
        let mut output_iter = replicated_state.output_into_iter();

        let mut i = start;
        let mut excluded = 0;
        let mut consumed = 0;
        while let Some((queue_id, msg)) = output_iter.peek() {
            i += 1;
            if i % exclude_step == 0 {
                output_iter.exclude_queue();
                excluded += 1;
            } else {
                assert_eq!(Some((queue_id, msg.clone())), output_iter.next());
                consumed += 1;
            }
        }

        drop(output_iter);
        assert_eq!(total_requests, excluded + consumed);
        assert_eq!(replicated_state.output_message_count(), excluded);
    }

    #[test]
    fn iter_yields_correct_elements(
       (mut replicated_state, mut raw_requests, _total_requests) in arb_replicated_state_with_queues(SUBNET_ID, 20, 20, None),
    ) {
        let mut output_iter = replicated_state.output_into_iter();

        for (_, msg) in &mut output_iter {
            let mut requests = raw_requests.pop_front().unwrap();
            while requests.is_empty() {
                requests = raw_requests.pop_front().unwrap();
            }

            if let Some(raw_msg) = requests.pop_front() {
                assert_eq!(msg, raw_msg, "Popped message does not correspond with expected message. popped: {:?}. expected: {:?}.", msg, raw_msg);
            } else {
                panic!("Pop yielded an element that was not contained in the respective queue");
            }

            raw_requests.push_back(requests);
        }

        drop(output_iter);
        // Ensure that actually all elements have been consumed.
        assert_eq!(raw_requests.iter().map(|requests| requests.len()).sum::<usize>(), 0);
        assert_eq!(replicated_state.output_message_count(), 0);
    }

    #[test]
    fn iter_with_ignore_yields_correct_elements(
       (mut replicated_state, mut raw_requests, total_requests) in arb_replicated_state_with_queues(SUBNET_ID, 10, 10, None),
        start in 0..=1,
        ignore_step in 2..=5,
    ) {
        let mut consumed = 0;
        let mut ignored_requests = Vec::new();
        // Check whether popping elements with ignores in between yields the expected messages
        {
            let mut output_iter = replicated_state.output_into_iter();

            let mut i = start;
            while let Some((_, msg)) = output_iter.peek() {

                let mut requests = raw_requests.pop_front().unwrap();
                while requests.is_empty() {
                    requests = raw_requests.pop_front().unwrap();
                }

                i += 1;
                if i % ignore_step == 0 {
                    // Popping the front of the requests will amount to the same as ignoring as
                    // we use queues of size one in this test.
                    let popped = requests.pop_front().unwrap();
                    assert_eq!(*msg, popped);
                    output_iter.exclude_queue();
                    ignored_requests.push(popped);
                    // We push the queue to the front as the canister gets another chance if one
                    // of its queues are ignored in the current implementation.
                    raw_requests.push_front(requests);
                    continue;
                }

                let (_, msg) = output_iter.next().unwrap();
                if let Some(raw_msg) = requests.pop_front() {
                    consumed += 1;
                    assert_eq!(msg, raw_msg, "Popped message does not correspond with expected message. popped: {:?}. expected: {:?}.", msg, raw_msg);
                } else {
                    panic!("Pop yielded an element that was not contained in the respective queue");
                }

                raw_requests.push_back(requests);
            }
        }

        let remaining_output = replicated_state.output_message_count();

        assert_eq!(remaining_output, total_requests - consumed);
        assert_eq!(remaining_output, ignored_requests.len());

        for raw in ignored_requests {
            let queues = if let Some(canister) = replicated_state.canister_states.get_mut(&raw.sender()) {
                canister.system_state.queues_mut()
            } else {
                replicated_state.subnet_queues_mut()
            };

            let msg = queues.pop_canister_output(&raw.receiver()).unwrap();
            assert_eq!(raw, msg);
        }

        assert_eq!(replicated_state.output_message_count(), 0);

    }

    #[test]
    fn peek_next_loop_terminates(
        (mut replicated_state, _, _) in arb_replicated_state_with_queues(SUBNET_ID, 20, 20, Some(8)),
    ) {
        let mut output_iter = replicated_state.output_into_iter();

        while output_iter.peek().is_some() {
            output_iter.next();
        }
    }

    #[test]
    fn ignore_leaves_state_untouched(
        (mut replicated_state, _, _) in arb_replicated_state_with_queues(SUBNET_ID, 20, 20, Some(8)),
    ) {
        let expected_state = replicated_state.clone();
        {
            let mut output_iter = replicated_state.output_into_iter();

            while output_iter.peek().is_some() {
                output_iter.exclude_queue();
            }
        }

        assert_eq!(expected_state, replicated_state);
    }

    #[test]
    fn peek_next_loop_with_ignores_terminates(
        (mut replicated_state, _, _) in arb_replicated_state_with_queues(SUBNET_ID, 20, 20, Some(8)),
        start in 0..=1,
        ignore_step in 2..=5,
    ) {
        let mut output_iter = replicated_state.output_into_iter();

        let mut i = start;
        while output_iter.peek().is_some() {
            i += 1;
            if i % ignore_step == 0 {
                output_iter.exclude_queue();
                continue;
            }
            output_iter.next();
        }
    }
}
